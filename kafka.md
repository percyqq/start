如何做到消息不丢失  
==
* ACK 机制  
>通过 ACK 机制保证消息送达。Kafka 采用的是至少一次（At least once），消息不会丢，但是可能会重复传输  

* 发送消息   
>为了得到更好的性能，Kafka 支持在生产者一侧进行本地buffer，<br>
>也就是累积到一定的条数才发送，如果这里设置不当是会丢消息的。<br>
>生产者端设置 producer.type=async, sync，默认是 sync。<br>
>当设置为 async，会大幅提升性能，因为生产者会在本地缓冲消息，并适时批量发送。<br>
>如果对可靠性要求高，那么这里可以设置为 sync 同步发送。<br>

* 消费消息<br>
>如果更注重可靠性，则需要显示提交 Offset，也就是当所有业务都处理完成的时候，再提交Offset。<br>
>这样会导致重复消费，需要提供幂等性接口。通过增加消费组的消费者来进行水平扩展提升消费能力。<br>
>这也是为什么建议创建主题时使用比较多的分区数，这样可以在消费负载高的情况下增加消费者来提升性能。<br>
>另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助。<br>
<br>

为什么 Kafka 性能高？
==

* 顺序写磁盘<br>
>顺序写磁盘的性能是随机写入的性能的6000倍的提升，媲美内存随机访问的性能，磁盘不再是瓶颈点。<br>

* Page Cache<br>
>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。<br>
>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。<br>

* 零拷贝技术<br>
>零拷贝技术，可以有效的减少上下文切换和拷贝次数。<br>
>kafka的设计实现，涉及到很多的底层技术，为了能够把它吃透，需要花大量的时间，大量的精力。

<br><br><br><br>



Kafka一个很重要的特性就是，只需写入一次消息，可以支持任意多的应用读取这个消息。换句话说，每个应用都可以读到全量的消息。
为了使得每个应用都能读到全量消息，应用需要有不同的消费组。
  比如：订单生产后，产生了一条消息==>后续  【库存】需要消费当前的消息，【积分】也需要~


![多分组](https://github.com/percyqq/start/blob/master/pic/kafka%20group.png?raw=true)

消费组与分区重平衡
可以看到，当新的消费者加入消费组，它会消费一个或多个分区，而这些分区之前是由其他消费者负责的；
另外，当消费者离开消费组（比如重启、宕机等）时，它所消费的分区会分配给其他分区。这种现象称为重平衡（rebalance）。

重平衡是Kafka一个很重要的性质，这个性质保证了高可用和水平扩展。
不过也需要注意到，在重平衡期间，所有消费者都不能消费消息，因此会造成整个消费组短暂的不可用。
而且，将分区进行重平衡也会导致原来的消费者状态过期，从而导致消费者需要重新更新状态，这段期间也会降低消费性能







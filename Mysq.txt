https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961498&idx=1&sn=058097f882ff9d32f5cdf7922644d083&chksm=bd2d0d468a5a845026b7d2c211330a6bc7e9ebdaa92f8060265f60ca0b166f8957cbf3b0182c&scene=21#wechat_redirect


======================================================================================================================================
并发版本控制
总结
(1)常见并发控制保证数据一致性的方法有锁，数据多版本；
(2)普通锁串行，读写锁读读并行，数据多版本读写并行；
(3)redo日志保证已提交事务的ACID特性，设计思路是，通过顺序写替代随机写，提高并发；
(4)undo日志用来回滚未提交的事务，它存储在回滚段里；
(5)InnoDB是基于MVCC的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；
(6)InnoDB之所以并发高，快照读不加锁；
(7)InnoDB所有普通select都是快照读；


三，可重复读(Repeated Read, RR)
这是InnoDB默认的隔离级别，在RR下：

(1)普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现，
共享锁与排他锁的玩法是：
  共享锁之间不互斥，简记为：读读可以并行
  排他锁与任何锁互斥，简记为：写读，写写不可以并行
  
数据多版本是一种能够进一步提高并发的方法，它的核心原理是：
（1）写任务发生时，将数据克隆一份，以版本号区分；
（2）写任务操作新克隆的数据，直至提交；
（3）并发读任务可以继续读取旧版本的数据，不至于阻塞；  

(2)加锁的select(select ... in share mode / select ... for update), update, delete等语句，它们的锁，依赖于它们是否在唯一索引(unique index)上
使用了唯一的查询条件(unique search condition)，或者范围查询条件(range-type search condition)：
在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)，而不会封锁记录之间的间隔，即不会使用间隙锁(gap lock)与临键锁(next-key lock)
范围查询条件，会使用间隙锁与临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复的读


InnoDB是高并发互联网场景最为推荐的存储引擎，根本原因，就是其多版本并发控制（Multi Version Concurrency Control, MVCC）。
行锁，并发，事务回滚等多种特性都和MVCC相关。
MVCC就是通过“读取旧版本数据”来降低并发事务的锁冲突，提高任务的并发度。


======================================================================================================================================
四、redo, undo,回滚段

为什么要有redo日志？    一句话，redo日志用于保障，已提交事务的ACID特性。
  数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。磁盘随机写性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。
  优化方式是，将修改行为先写到redo日志里（此时变成了顺序写），再定期将数据刷到磁盘上，这样能极大提高性能。

为什么要有undo日志？    undo日志用于保障，未提交事务不会对数据库的ACID特性产生影响。
  数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，
  即旧版本数据，撤销未提交事务对数据库产生的影响。

  对于insert操作，undo日志记录新数据的PK(ROW_ID)，回滚时直接删除；
  对于delete/update操作，undo日志记录旧数据row，回滚时直接恢复；
  他们分别存放在不同的buffer里。

什么是回滚段？
  存储undo日志的地方，是回滚段。


======================================================================================================================================
索引总结

  数据库索引用于加速查询
  虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引
  InnoDB不支持哈希索引
  数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO
  局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO


数据库的索引最常用B+树：
(1)很适合磁盘存储，能够充分利用局部性原理，磁盘预读；
(2)很低的树高度，能够存储大量数据；
(3)索引本身占用的内存很小；
(4)能够很好的支持单点查询，范围查询，有序性查询；

(a)在索引结构中，非叶子节点存储key，叶子节点存储value；
(b)聚集索引，叶子节点存储行记录(row)；



InnoDB的主键索引与行记录是存储在一起的，故叫做聚集索引（Clustered Index）：
  1.没有单独区域存储行记录
  2.主键索引的叶子节点，存储主键，与对应行记录（而不是指针）
  ==> 聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。
  
InnoDB的每一个表都会有聚集索引：
(1)如果表定义了PK，则PK就是聚集索引；
(2)如果表没有定义PK，则第一个非空unique列是聚集索引；
(3)否则，InnoDB会创建一个隐藏的row-id作为聚集索引；



MyISAM的索引与行记录是分开存储的，叫做非聚集索引（UnClustered Index）。
其主键索引与普通索引没有本质差异：
  1.有连续聚集的区域单独存储行记录
  2.主键索引的叶子节点，存储主键，与对应行记录的指针
  3.普通索引的叶子结点，存储索引列，与对应行记录的指针
  
  
InnoDB的普通索引可以有多个，它与聚集索引是不同的：
普通索引的叶子节点，存储主键（也不是指针）

InnoDB的索引
  InnoDB的索引有两类索引，聚集索引(Clustered Index)与普通索引(Secondary Index)。
  
  
  

 对于InnoDB表，这里的启示是：
(1)不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；
(2)建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；

MyISAM和InnoDB都使用B+树来实现索引：
  MyISAM的索引与数据分开存储
  MyISAM的索引叶子存储指针，主键索引与普通索引无太大区别
  InnoDB的聚集索引和数据行统一存储
  InnoDB的聚集索引存储数据行本身，普通索引存储主键
  InnoDB一定有且只有一个聚集索引
  InnoDB建议使用趋势递增整数作为PK，而不宜使用较长的列作为PK

======================================================================================================================================

记录锁(Record Locks)     
  记录锁，它封锁索引记录，例如：
  select * from t where id=1 for update;
  
快照读(SnapShot Read)，它并不加锁，
  select * from t where id=1;
  
间隙锁(Gap Locks)
  间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。  
  
InnoDB，RR：
t(id PK, name KEY, sex, flag);
表中有四条记录：
  1, shenjian, m, A
  3, zhangsan, m, A
  5, lisi, m, A
  9, wangwu, f, B
  
这个SQL语句
select * from t     where id between 8 and 15     for update;
会封锁区间，以阻止其他事务id=10的记录插入。  
  
  间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。
  如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。 


临键锁(Next-Key Locks)
  临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。
  更具体的，临键锁会封锁索引记录本身，以及索引记录之前的区间。
  如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。
  
  临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。

PK上潜在的临键锁为：

(-infinity, 1]
(1, 3]
(3, 5]
(5, 9]
(9, +infinity]


总结

(1)InnoDB的索引与行记录存储在一起，这一点和MyISAM不一样；
(2)InnoDB的聚集索引存储行记录，普通索引存储PK，所以普通索引要查询两次；
(3)记录锁锁定索引记录；
(4)间隙锁锁定间隔，防止间隔中被其他事务插入；
(5)临键锁锁定索引记录+间隔，防止幻读；





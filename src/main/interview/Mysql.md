
你能说说为什么B+树相对于B树在查询上会更加优胜吗？
除了上面这个范围查询的，你还能说出其他的一些区别吗？
刚刚我们聊到B+ Tree，那你知道B+Tree的叶子节点都可以存哪些东西吗？
聚簇索引和非聚簇索引，在查询数据的时候有区别吗？
刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。是所有情况都是这样的吗？非主键索引一定会查询多次吗？
联合索引、最左前缀匹配
你们在创建索引的时候都会考虑哪些因素呢？你们有用过联合索引吗？
那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？
索引下推、查询优化
你知道在MySQL 5.6中，对索引做了哪些优化吗？
你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？
那排查的时候，有什么手段可以知道有没有走索引查询呢？
那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？
哦，索引有关的知识我们暂时就问这么多吧。你们线上数据的事务隔离级别是什么呀？


https://www.jianshu.com/p/c189439fb32e
    MySQL 万字精华总结

exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，
    当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；
    反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，
    exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false
in：in查询相当于多个or条件的叠加
SELECT * FROM A WHERE A.id IN (SELECT id FROM B);
SELECT * FROM A WHERE EXISTS (SELECT * from B WHERE B.id = A.id);
如果查询的两个表大小相当，那么用in和exists差别不大。

[如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in]



https://tech.meituan.com/2014/06/30/mysql-index.html  
    MySQL索引原理及慢查询优化  


链接：https://www.jianshu.com/p/5f39ad4a710d
从Kafka的索引冷热分区到MySQL InnoDB的缓冲池管理
从上面这波冷热分区我又想到了MySQL的buffer pool管理。
    MySQL的将缓冲池分为了新生代和老年代。默认是37分，即老年代占3，新生代占7。
    即看作一个链表的尾部30%为老年代，前面的70%为新生代。替换了标准的LRU淘汰机制。
    
[MySQL的缓冲池分区是为了解决预读失效和缓存污染问题。]
    1、预读失效：因为会预读页，假设预读的页不会用到，那么就白白预读了，
        因此让预读的页插入的是老年代头部，淘汰也是从老年代尾部淘汰。不会影响新生代数据。
    2、缓存污染：在类似like全表扫描的时候，会读取很多冷数据。并且有些查询频率其实很少，
        因此让这些数据仅仅存在老年代，然后快速淘汰才是正确的选择，
        MySQL为了解决这种问题，仅仅分代是不够的，还设置了一个时间窗口，默认是1s，
        即在老年代被再次访问并且存在超过1s，才会晋升到新生代，这样就不会污染新生代的热数据。


#B-Tree的特点
   所有键值分布在整个树中（区别与B+树，B+树的值只分部在叶子节点上）
    任何关键字出现且只出现在一个节点中（区别与B+树）
     搜索有可能在非叶子节点结束（区别与B+树，因为值都在叶子节点上，只有搜到叶子节点才能拿到值）
     在关键字全集内做一次查找，性能逼近二分查找算法
[B+树的结构特点]
    1.B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，
        再在内存中进行查找，最后得到要查找的数据。数据的读取是精确到页的，因为页是计算机管理存储器的逻辑块，
        IO的磁盘读取，每次都读取数据的大小是一个页大小的整数倍。
    2.假设B+Tree的高度为h，一次检索最多需要h-1次I/O（根节点常驻内存），复杂度O(h) = O(logmN)，
        m指的是一个节点存储的数据的个数。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。
    3.B+树与B树的不同在于：
        所有关键字存储在叶子节点，非叶子节点不存储真正的data
        [为所有叶子节点（左右相邻的节点之间）增加了一个链指针]
    4.为什么数据库使用B+而不使用红黑树呢？
        a.计算器在IO磁盘读取的时候，为了降低读取的次数，默认一次会读取一个页的数据量，MySQL(默认使用InnoDB引擎),
            将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。
            linux 默认页大小为4K。所以每次IO读取，都是读取一个页的数据量，
            [所以B树的节点都是存储一个页的节点，这样的查询效率才是最高的]
        b.每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，
            就实现了一个结点只需一次I/O。这样大大降低了树的高度
    5.为什么mysql的索引使用B+树而不是B树呢？
        a.范围查找更快，mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，
            加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。
            而B树的数据有一部分存在在非叶子节点上面，而且默认的B树的相邻的叶子节点之间是没有指针的，所以范围查找相对更慢。
        b.降低树的高度，但是最底下一层的节点会更多，因为所有的数据都堆积在最底下一层了，用空间换速度。
            [B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，]
            每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高

经常增删改的列不要建立索引；
有大量重复的列不建立索引；
表记录太少不要建立索引。

建索引的几大原则
1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
    比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
    如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，
    比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，
    那可能有人会问，这个比例有什么经验值吗？
    使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，
    原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。
    所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

由上面可知，当sql语句的所求查询字段（select列）和查询条件字段（where子句）全都包含在一个索引中，可以直接使用索引查询而不需要回表。
    这就是覆盖索引，通过使用覆盖索引，可以减少搜索树的次数，是常用的性能优化手段。
    
[索引下推]可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数。
1、innodb引擎的表，索引下推只能用于二级索引。
 就像之前提到的，innodb的主键索引树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。

2、索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。
假设表t有联合索引（a,b）,下面语句可以使用索引下推提高效率
select * from t where a > 2 and b > 10;

索引总结
    数据库索引用于加速查询
    虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引
    InnoDB不支持哈希索引
    数据预读的思路是：[磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO]
    局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO

数据库的索引最常用B+树：
>(1)很适合磁盘存储，能够充分利用局部性原理，磁盘预读；  
>(2)很低的树高度，能够存储大量数据；  
>(3)索引本身占用的内存很小；  
>(4)能够很好的支持单点查询，范围查询，有序性查询；  

>(a)在索引结构中，非叶子节点存储key，叶子节点存储value；
>(b)聚集索引，叶子节点存储行记录(row)；

* 聚集索引（Clustered Index）与非聚集索引（UnClustered Index）
InnoDB的主键索引与行记录是存储在一起的，故叫做聚集索引（Clustered Index）：
>1.没有单独区域存储行记录  
>2.主键索引的叶子节点，存储主键，与对应行记录（而不是指针）  
>==> 聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。  
  
InnoDB的每一个表都会有聚集索引：
>(1)如果表定义了PK，则PK就是聚集索引；  
>(2)如果表没有定义PK，则第一个非空unique列是聚集索引；  
>(3)否则，InnoDB会创建一个隐藏的row-id作为聚集索引；  


* MyISAM的索引与行记录是分开存储的，叫做非聚集索引（UnClustered Index）。  
其主键索引与普通索引没有本质差异：  
>1.有连续聚集的区域单独存储行记录  
>2.主键索引的叶子节点，存储主键，与对应行记录的指针  
>3.普通索引的叶子结点，存储索引列，与对应行记录的指针  
  
  
* InnoDB的普通索引可以有多个，它与聚集索引是不同的：  
普通索引的叶子节点，存储主键（也不是指针）  

InnoDB的索引  
>InnoDB的索引有两类索引，聚集索引(Clustered Index)与普通索引(Secondary Index)。  

* 聚簇索引的优点
>聚簇索引将索引和数据行保存在同一个B-Tree中，查询通过聚簇索引可以直接获取数据，
>相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。
>聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的，
  
* 聚簇索引的缺点
>1.聚簇索引的更新代价比较高，如果更新了行的聚簇索引列，就需要将数据移动到相应的位置。  
>这可能因为要插入的页已满而导致“页分裂”。  
>2.插入速度严重依赖于插入顺序，按照主键进行插入的速度是加载数据到Innodb中的最快方式。  
>如果不是按照主键插入，最好在加载完成后使用OPTIMIZE TABLE命令重新组织一下表。  
>3.聚簇索引在插入新行和更新主键时，可能导致“页分裂”问题。  
>4.聚簇索引可能导致全表扫描速度变慢，因为可能需要加载物理上相隔较远的页到内存中（需要耗时的磁盘寻道操作）。  

 对于InnoDB表，这里的启示是：
(1)不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；
(2)建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；

MyISAM和InnoDB都使用B+树来实现索引：
  MyISAM的索引与数据分开存储
  MyISAM的索引叶子存储指针，主键索引与普通索引无太大区别
  InnoDB的聚集索引和数据行统一存储
  InnoDB的聚集索引存储数据行本身，普通索引存储主键
  InnoDB一定有且只有一个聚集索引
  InnoDB建议使用趋势递增整数作为PK，而不宜使用较长的列作为PK

======================================================================================================================================

https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961444&idx=1&sn=830a93eb74ca484cbcedb06e485f611e&chksm=bd2d0db88a5a84ae5865cd05f8c7899153d16ec7e7976f06033f4fbfbecc2fdee6e8b89bb17b&scene=21#wechat_redirect

四、redo, undo,回滚段  
==
为什么要有redo日志？    一句话，redo日志用于保障，已提交事务的ACID特性。
>数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。  
>磁盘随机写性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。  
>优化方式是，将修改行为先写到redo日志里（此时变成了顺序写），再定期将数据刷到磁盘上，这样能极大提高性能。  
  
为什么要有undo日志？    undo日志用于保障，未提交事务不会对数据库的ACID特性产生影响。
>数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，  
>当事务回滚时，或者数据库奔溃时，可以利用undo日志，  
>即旧版本数据，撤销未提交事务对数据库产生的影响。  

#对于insert操作，undo日志记录新数据的PK(ROW_ID)，回滚时直接删除；  
#对于delete/update操作，undo日志记录旧数据row，回滚时直接恢复；  
>他们分别存放在不同的buffer里。  

什么是回滚段？  
>存储undo日志的地方，是回滚段。  


[mvcc并发版本控制]
总结
>(1)常见并发控制保证数据一致性的方法有锁，数据多版本；  
>(2)普通锁串行，读写锁读读并行，数据多版本读写并行；  
>(3)redo日志保证已提交事务的ACID特性，设计思路是，通过顺序写替代随机写，提高并发；  
>(4)undo日志用来回滚未提交的事务，它存储在回滚段里；  
>(5)InnoDB是基于MVCC的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；  
>(6)InnoDB之所以并发高，快照读不加锁；  
>(7)InnoDB所有普通select都是快照读；  


https://www.jianshu.com/p/d75fcdeb07a3
#不同隔离级别带来的数据操作问题：
1.脏读：两个事务，t1事务可以读取到t2事务正在做更改的数据的中间状态(t2事务执行过程中)，而这个数据的更改有可能不会被持久化(commit)，
    而是rollback，导致t1在同一事务内的两次读取同一行数据得到结果不同。
2.不可重复读：t1事务在整个事务执行过程中读取某一条记录多次，发现读取的此条记录不是每次都一样。
3.幻读：t1事务在整个事务执行过程中读取某一范围内的数据，在第二次读取时发现多了几行或者少了几行。

#数据库中的几种隔离级别
1.read uncommited--读未提交
    该隔离级别指即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变，几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用。
2.read committed --读已提交
    该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和第一类丢失更新，
    这是大多数数据库的默认隔离级别，如Oracle,Sqlserver。
3.repeatable read --可重复读
    该隔离级别指一个事务中进行两次或多次同样的对于[数据内容]的查询，得到的结果是一样的，但不保证对于[数据条数]的查询是一样的，
    只要存在读改行数据就禁止写，消除了不可重复读和第二类更新丢失，这是Mysql数据库的默认隔离级别。
4.serializable --序列化读
    意思是说这个事务执行的时候不允许别的事务并发写操作的执行.完全串行化的读，只要存在读就禁止写,但可以同时读，消除了幻读。
    这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用。

#数据库中的锁:
1.共享锁（Share locks简记为S锁）：也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。
2.排它锁（Exclusivelocks简记为X锁）：也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。
3.更新锁（简记为U锁）：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；
    当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。
    因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。
    这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。
    这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。
    如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。


https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961498&idx=1&sn=058097f882ff9d32f5cdf7922644d083&chksm=bd2d0d468a5a845026b7d2c211330a6bc7e9ebdaa92f8060265f60ca0b166f8957cbf3b0182c&scene=21#wechat_redirect

[快照读（Snapshot Read），这种一致性不加锁的读（Consistent Nonlocking Read），就是InnoDB并发如此之高的核心原因之一]
#case
事务A，先执行：            select * from t where id=1;     结果集为： 1, shenjian
事务B，后执行，并且提交：    update t set name=xxoo where id=1;         commit;
事务A，再次执行相同的查询：  select * from t where id=1;     结果集为： 1, xxoo
 这次是已提交事务B对事务A产生的影响，这个影响叫做“不可重复读”，一个事务内相同的查询，得到了不同的结果。
 同理， “幻读”是insert语句

1.串行化(Serializable)
    这种事务的隔离级别下，所有select语句都会被隐式的转化为select ... in share mode.
    这可能导致，如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞住。

2，可重复读(Repeated Read, RR)
==
这是InnoDB默认的隔离级别，在RR下：  
* (1)普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现，共享锁与排他锁的玩法是：   
    >共享锁之间不互斥，简记为：读读可以并行  
    >排他锁与任何锁互斥，简记为：写读，写写不可以并行  
  
        数据多版本是一种能够进一步提高并发的方法，它的核心原理是：    
        >（1）写任务发生时，将数据克隆一份，以版本号区分；  
        >（2）写任务操作新克隆的数据，直至提交；  
        >（3）并发读任务可以继续读取旧版本的数据，不至于阻塞；  

* (2)加锁的select(select ... in share mode / select ... for update), update, delete等语句，它们的锁，  
    依赖于它们是否在唯一索引(unique index)上使用了唯一的查询条件(unique search condition)，  
    或者范围查询条件(range-type search condition)：  
   1.在[唯一索引]上使用唯一的查询条件，会使用[记录锁(record lock)]，而不会封锁记录之间的间隔，
        即不会使用[间隙锁(gap lock)]与[临键锁(next-key lock)]
   2.范围查询条件，会使用间隙锁与临键锁，  
        锁住索引记录之间的范围，避免范围间插入记录，以避免产生[幻影行]记录，以及避免[不可重复的读] 



#来看一个案列分析       https://mp.weixin.qq.com/s/Gc2MifYwxsfbOtoM22cM_w
[Read Uncommitted]：可以读取未提交记录。此隔离级别不会使用。
[Read Committed（RC）]：针对当前读，RC隔离级别保证了对读取到的记录加锁（记录锁），存在幻读现象。
[Repeatable Read（RR）]：针对当前读，RR隔离级别保证对读取到的记录加锁（记录锁），同时保证对读取的范围加锁，
    新的满足查询条件的记录不能够插入（间隙锁），不存在幻读现象。
[Serializable]：从MVCC并发控制退化为基于锁的并发控制。不区别快照读和当前读，所有的读操作都是当前读，读加读锁（S锁），写加写锁（X锁）。
    在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。


InnoDB是高并发互联网场景最为推荐的存储引擎，根本原因，  
就是其多版本并发控制（Multi Version Concurrency Control, MVCC）。  
行锁，并发，事务回滚等多种特性都和MVCC相关。  
MVCC就是通过“读取旧版本数据”来降低并发事务的锁冲突，提高任务的并发度。  


在InnoDB中完整行锁包含三部分：
[记录锁（Record Lock）]   记录锁锁定索引中的一条记录。
[间隙锁（Gap Lock）]      间隙锁要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或最后一个索引记录后面的值。
[Next-Key Lock]         Next-Key锁时索引记录上的记录锁和在记录之前的间隙锁的组合。

# table T (id int, name varchar(20))
delete from T where id = 10;

读加读锁（S锁），写加写锁（X锁）
结论：
    在RR隔离级别下，id列上有非唯一索引，对于上述的SQL语句；首先，通过id索引定位到第一条满足条件的记录，给记录加上X锁，
        并且给Gap加上Gap锁，然后在主键聚簇索引上满足相同条件的记录加上X锁，然后返回；
        之后读取下一条记录重复进行。直至第一条出现不满足条件的记录，此时，不需要给记录加上X锁，但是需要给Gap加上Gap锁吗，最后返回结果。



记录锁(Record Locks)     
  记录锁，它封锁索引记录，例如：
  select * from t where id=1 for update;
  
快照读(SnapShot Read)，它并不加锁，
  select * from t where id=1;
  
间隙锁(Gap Locks)
  间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。  
  
InnoDB，RR：
t(id PK, name KEY, sex, flag);
表中有四条记录：
  1, shenjian, m, A
  3, zhangsan, m, A
  5, lisi, m, A
  9, wangwu, f, B
  
这个SQL语句
select * from t     where id between 8 and 15     for update;
会封锁区间，以阻止其他事务id=10的记录插入。  
  
  间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。
  如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。 


临键锁(Next-Key Locks)
  临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。
  更具体的，临键锁会封锁索引记录本身，以及索引记录之前的区间。
  如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。
  
  临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。

PK上潜在的临键锁为：

(-infinity, 1]
(1, 3]
(3, 5]
(5, 9]
(9, +infinity]


总结

(1)InnoDB的索引与行记录存储在一起，这一点和MyISAM不一样；
(2)InnoDB的聚集索引存储行记录，普通索引存储PK，所以普通索引要查询两次；
(3)记录锁锁定索引记录；
(4)间隙锁锁定间隔，防止间隔中被其他事务插入；
(5)临键锁锁定索引记录+间隔，防止幻读；



======================================================================================================================================
https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961461&idx=1&sn=b73293c71d8718256e162be6240797ef&chksm=bd2d0da98a5a84bfe23f0327694dbda2f96677aa91fcfc1c8a5b96c8a6701bccf2995725899a&scene=21#wechat_redirect
InnoDB并发插入，居然使用意向锁？

一，共享/排它锁(Shared and Exclusive Locks)

《InnoDB并发为何这么高？》一文介绍了通用的共享/排它锁，在InnoDB里当然也实现了标准的行级锁(row-level locking)，共享/排它锁：
  (1)事务拿到某一行记录的共享S锁，才可以读取这一行；
  (2)事务拿到某一行记录的排它X锁，才可以修改或者删除这一行；
其兼容互斥表如下：
        S         X
S      兼容      互斥
X      互斥      互斥

即：
(1)多个事务可以拿到一把S锁，读读可以并行；
(2)而只有一个事务可以拿到X锁，写写/读写必须互斥；
共享/排它锁的潜在问题是，不能充分的并行，解决思路是数据多版本


二，意向锁(Intention Locks)
  InnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存，实际应用中，InnoDB使用的是意向锁。
  意向锁是指，未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向。

意向锁有这样一些特点：
(1)首先，意向锁，是一个表级别的锁(table-level locking)；
(2)意向锁分为：
  意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁
  意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁

举个例子：
select ... lock in share mode，要设置IS锁；
select ... for update，要设置IX锁；

(3)意向锁协议(intention locking protocol)并不复杂：
  事务要获得某些行的S锁，必须先获得表的IS锁
  事务要获得某些行的X锁，必须先获得表的IX锁

(4)由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行，其兼容互斥表如下：
         IS        IX
IS      兼容      兼容
IX      兼容      兼容

 
(5)额，既然意向锁之间都相互兼容，那其意义在哪里呢？它会与共享锁/排它锁互斥，其兼容互斥表如下：
         S         X
IS      兼容      互斥
IX      互斥      互斥
画外音：排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。


三，插入意向锁(Insert Intention Locks)

对已有数据行的修改与删除，必须加强互斥锁X锁，那对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。
插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。
画外音：有点尴尬，间隙锁下一篇文章才会介绍，暂且理解为，它是一种实施在索引上，锁定索引某个区间范围的锁。

它的玩法是：
多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。
画外音：官网的说法是

Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.


在MySQL，InnoDB，RR下：
t(id unique PK, name);

数据表中有数据：
10, shenjian
20, zhangsan
30, lisi

事务A先执行，在10与20两条记录中插入了一行，还未提交：
insert into t values(11, xxx);

事务B后执行，也在10与20两条记录中插入了一行：
insert into t values(12, ooo);

(1)会使用什么锁？
(2)事务B会不会被阻塞呢？
回答：虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：
  使用的是插入意向锁
  并不会阻塞事务B


思路总结

(1)InnoDB使用共享锁，可以提高读读并发；
(2)为了保证数据强一致，InnoDB使用强互斥锁，保证同一行记录修改与删除的串行性；
(3)InnoDB使用插入意向锁，可以提高插入并发；




缓冲池(buffer pool)
https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962450&idx=1&sn=ce17c4da8d20ce275f75d0f2ef5e40c9&chksm=bd2d098e8a5a809834aaa07da0d7546555385543fb6d687a7cf94d183ab061cd301a76547411&scene=21#wechat_redirect



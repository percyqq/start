
https://tech.meituan.com/2018/11/15/java-lock.html  
    不可不说的Java“锁”事  
    
ReentrantLock和synchronized都是重入锁
独享锁和共享锁同样是一种概念。
    我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。

a. synchronized不可中断等，
b.  ReentrantLock 未能读写分离实现，
c.   虽然ReentrantReadWriteLock能够读写分离了，
    但是对于其写锁想要获取的话，就必须没有任何其他读写锁存在才可以，这实现了悲观读取。
    而且如果读操作很多，写很少的情况下，线程有可能遭遇饥饿问题。
    [饥饿问题]：ReentrantReadWriteLock实现了读写分离，想要获取读锁就必须确保当前没有其他任何读写锁了，但是一旦读操作比较多的时候，
    想要获取写锁就变得比较困难了，因为当前有可能会一直存在读锁。而无法获得写锁。

这时候怎么办呢？于是在jdk1.8的时候引入了一个新的锁StampedLock。    一个带有邮戳的锁
二、简单使用
StampedLock控制锁有三种模式（写，读，乐观读）
（1）写入（Writing）：writeLock是一个独占锁，也是一个悲观锁。
（2）读取（Reading）：readLock这时候是一个悲观锁。
（3）乐观读取（Optimistic Reading）：提供了tryOptimisticRead方法返回一个非0的stamp，
    只有当前同步状态没有被写模式所占有是才能获取到。乐观读取模式仅用于短时间读取操作时经常能够降低竞争和提高吞吐量。
    同时使用的时候一般需要读取并存储到另外一个副本，以用做对比使用。下面干脆使用代码来实现一下这几种锁的实现。




[独享锁]也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。
    获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

[共享锁]是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。
    获得共享锁的线程只能读数据，不能修改数据。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

   [偏向锁]是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
        在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。
        其目标就是在只有一个线程执行同步代码块时能够提高性能。
   当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。
        在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。
        引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，
        因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。
   
   偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。
        偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），
        它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。
        [撤销偏向锁]后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
   偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，
        关闭之后程序默认会进入轻量级锁状态。 
   
   [轻量级锁] 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，
        其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。     
   [若当前只有一个等待线程，则该线程通过自旋进行等待。
    但是当自旋超过一定的次数，
    或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。]
    
   [重量级锁]是将除了拥有锁的线程以外的线程都阻塞。

产生死锁的四个必要条件：
*  （1） 互斥条件：一个资源每次只能被一个进程使用。  
*  （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
*  （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。  
*  （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。  


活锁
指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。
活锁同样会发生在多个相互协作的线程间，当他们为了彼此间的响应而相互礼让，使得没有一个线程能够继续前进，那么就发生了活锁。


后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。
如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。

CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：

* ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。
  但是如果内存值原来是A，后来变成了B，然后又变成了A，
  那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。
  ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，
  这样变化过程就从“A－B－A”变成了“1A－2B－3A”。  
        JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。
        compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，
        则以原子方式将引用值和标志的值设置为给定的更新值。
    
* 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。  
* 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，
但是对多个共享变量操作时，CAS是无法保证操作的原子性的。  
        Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

count(1), * , 列 区别   count(列)不统计null？ 

解决难题，分布式事物，我们是底层交互服务，不应侵入过多的业务，我们只保证数据准确性，业务调用方来保证业务数据可靠性，一致性

CM架构。
抽象领域服务。公共服务。
消息对接收集。 
    商品 ->  多个物品，同一时间段扣减导致死锁。
自建gateway网关。
解决eureka发现502。
死锁： rc模式，分段扣减，大事务拆分，定时任务最终一致。
    死锁，商品–>物品，1对多，并发场景下订单扣减商品，会导致多个物品库存扣减，同一商户，同一物品，短时间内？
    另外是联合主键，以及主键趋势递增（锁住的范围存在了交集？）。

##kafka消息背压测试。





对象头存储。

jvm cms详解
hashmap 2的n次方。


java对象的几种创建方式：
1. 使用new关键字	                        → 调用了构造函数
2. 使用Class类的newInstance方法           → 调用了构造函数   无参的构造函数
      反射调用私有的构造方法： ===>  使用 SecurityManager 和足够严格的限制安全政策。
      
3. 使用Constructor类的newInstance方法     → 调用了构造函数   newInstance方法调用有参数的和私有的构造函数。
4. 使用clone方法	                        → 没有调用构造函数
5. 使用反序列化	                        → 没有调用构造函数  
        当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。
动态代理：
Proxy.newProxyInstance(Robot.class.getClassLoader(), new Class[] {Robot.class,Null.class},  


1. 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；
2. 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；
3. 反射也是考虑了线程安全的，放心使用；
4. 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；
5. 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；
6. 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；
7. 调度反射方法，最终是由jvm执行invoke0()执行；



反射方法调用：
Proxy target = new Proxy();
Method method = Proxy.class.getDeclaredMethod("run");
method.invoke(target);





gcroot哪些对象，如何确定
cms，mysql页数据大小，
线程池验证，core满，队列满，增大至max时，第一个来的请求和队列里的请求谁先执行。
无事物方法调用有事物。


GC Roots的对象包括下面几种：
>虚拟机栈（栈帧中的本地变量表）中的引用的对象；
>方法区中类静态属性引用的对象；
>方法区中常量引用的对象；
>本地方法栈中JNI（一般说的Native方法）的引用的对象。

2.2 CMS垃圾回收的6个重要阶段
1、initial-mark 初始标记（CMS的第一个STW阶段），标记GC Root直接引用的对象，GC Root直接引用的对象不多，所以很快。
2、concurrent-mark 并发标记阶段，由第一阶段标记过的对象出发，所有可达的对象都在本阶段标记。
3、concurrent-preclean 并发预清理阶段，也是一个并发执行的阶段。
    在本阶段，会查找前一阶段执行过程中,从[新生代]晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，
    预清理阶段可以减少下一个stop-the-world 重新标记阶段的工作量。

4、concurrent-abortable-preclean 并发可中止的预清理阶段。这个阶段其实跟上一个阶段做的东西一样，
    也是为了减少下一个STW重新标记阶段的工作量。
    增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认5秒）或者Eden区使用占比达到期望比例（默认50%）就结束本阶段。

5、remark 重标记阶段（CMS的第二个STW阶段），暂停所有用户线程，从GC Root开始重新扫描整堆，标记存活的对象。
    需要注意的是，虽然CMS只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，
    因为很多GC Root都在新生代，而这些GC Root指向的对象又在老年代，这称为“跨代引用”。

6、concurrent-sweep ，并发清理。



为什么选择网关： 【在高并发和潜在的高延迟场景下，网关要实现高性能高吞吐量的一个基本要求是全链路异步，不要阻塞线程。
    Zuul网关采用同步阻塞模式不符合要求。】
全局sso接入，cors配置，权限校验，
订单扣减拆分： 加菜，退菜，拆单，

1.自建gateway网关，底层基于netty，reactor非阻塞模式，优于cloud 1.0的zuul（thread-per-request处理模型，不支持任何长连接，如websockets）。
    即使在Controller方法上加@Async注解或返回DeferredResult、Callable类型的结果，
    其实仍只是把方法的同步调用封装成执行任务放到线程池的任务队列中，还是thread-per-request模型。
    Gateway 中Websockets得到支持，后续考虑做推送
  a.路由配置、
  b.断路器、
  c.限流、   基于令牌桶的限流过滤器、基于漏桶算法的限流过滤器    
            随着时间流逝，系统会按恒定 1/QPS 时间间隔（如果 QPS=100，则间隔是 10ms）往桶里加入 Token，如果桶已经满了就不再加了。
            每个请求来临时，会拿走一个 Token，如果没有 Token 可拿了，就阻塞或者拒绝服务。
            令牌桶的另外一个好处是可以方便的改变速度。一旦需要提高速率，则按需提高放入桶中的令牌的速率。一般会定时
            （比如 100 毫秒）往桶中增加一定数量的令牌，有些变种算法则实时的计算应该增加的令牌的数量。
  d.鉴权、
  e.cors、
  f.对外api接口统计


2.库存交易凭证，mongo 分片存储，3副本集提供服务，保证一致性不丢失，是系统交易信息的核心保证。
库存服务：
前置，分布式锁，保证库存扣减一致性，幂等。
中置，RC模式，减少间隙锁，分段扣减。
后置，定时任务，库存凭证扫描，计算报表数据差异，检查异常扣减。
    
3.抽象【核心业务领域层】：  供应链核心 ： 物品在【单据】之间的流转 和 库存。
a.基础公共服务，账户体系，提供分表路由。
b.物品服务，商品异步消息同步，大批量数据导入
d.单据服务，抽离，支持上层服务调用，后续可以接入流程引擎做单据履约。
c.出入库服务   对生产，报废，采购，销售，配送，盘点，订单各业务 提供基础的库存扣减，流水核对，为报表提供宽表计算数据
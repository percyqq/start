浅谈Redis中的Rehash机制       渐进式哈希(rehashing)  
 https://blog.csdn.net/cqk0100/article/details/80400811  

https://www.jianshu.com/p/3335fab1c1f2  
redis系列之淘汰删除  

美团针对Redis Rehash机制的探索和实践  
https://www.cnblogs.com/meituantech/p/9376472.html  

Redis 高负载下的中断优化  
https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html  



缓存服务的更新策略有哪些？  
https://www.jianshu.com/p/22c7e9ab5d15  

缓存的过期时间问题：
设计缓存的过期时间需要非常的有技巧，且必须与业务实际情况相结合。
因为如果设计的过期时间太短了，那会导致缓存效果不佳，
且还会造成频繁的从数据库中往缓存里写数据。如果缓存设计的过期时间太长了，又会导致内存的浪费。

缓存的命中率问题：
这也是设计缓存中需要存放哪些数据的很重要一点，如果设计的不好，可能会导致缓存命中率过低，失去缓存效果。
一般对于热点数据而言，要保证命中率达到70%以上效果最佳。

缓存的穿透/雪崩问题：
是指如果缓存服务一旦宕机或全部丢失，那么有可能一瞬间所有的流量都直接打到了后端数据库上，可能会造成连锁反应，
瞬间的请求高峰极有可能导致数据库无法承载。


典型的缓存模式，一般有如下几种：

Cache Aside
  应用在查询数据的时候，先从缓存Cache中读取数据，如果缓存中没有，则再从数据库中读取数据，得到数据库数据后，将其也放到缓存Cache中。
  如果应用要更新某个数据，也是先去更新数据库中的数据，更新完成之后，则通过指令让缓存Cache中的数据失效。
  
  这里为什么不让更新操作在写完数据库之后，紧接着去把缓存Cache中的数据也修改了呢？
  主要是因为这样做的话，就有2个写操作的事件了，担心在并发的情况下会导致脏数据，举个例子：
    假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去更新数据。
    初始状态缓存中是没有数据的，当请求A读到数据之后，准备往回写的时候，
    此刻，请求B正好要更新数据，更新完了数据库之后，又去把缓存更新了，那请求A再往缓存中写的就是旧数据了，属于脏数据。

那么 Cache Aside 模式就没有脏数据问题了吗？不是的，在极端情况下也可能会产生脏数据，比如：
  假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去写数据。
  假如初始状态缓存中没有这个数据，那请求A发现缓存中没有数据，就会去数据库中读数据，读到了数据准备写回缓存中，
  就在这个时候，请求B是要去写数据的，请求B在写完数据库的数据之后，又去设置了缓存失效。
  这个时候，请求A由于在数据库中读到了之前的旧数据，开始往缓存中写数据了，此时写进入的就也是旧数据。
  那么最终就会导致，缓存中的数据与数据库的数据不一致，造成了脏数据。

不过这种概率比上面一种概率要小很多。所以整体而言 Cache Aside 模式 还是一种比较简单实用的方式。

 
Read/Write Through
  这个模式其实就是将 缓存服务 作为主要的存储，应用的所有读写请求都是直接与缓存服务打交道，而不管最后端的数据库了，
  数据库的数据由缓存服务来维护和更新。不过缓存中数据变更的时候是同步去更新数据库的，在应用的眼中只有缓存服务。

流程就相当简单了：
  应用要读数据和更新数据都直接访问缓存服务
  缓存服务同步的将数据更新到数据库
  这个模式出现脏数据的概率就比较低，但是就强依赖缓存了，对缓存服务的稳定性有较大要求，另外，增加新缓存节点时还会有初始状态空数据问题。
  
Write Behind
  这个模式就是 Read/Write Through 模式 的一个变种。
  区别就是 Read/Write Through 模式的缓存写数据库的时候是同步的，而 Write Behind 模式 的缓存操作数据库是异步的。

流程如下：
  应用要读数据和更新数据都直接访问缓存服务
  缓存服务异步的将数据更新到数据库（通过异步任务）
  这个模式的特点就是速度很快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。

以上就是目前三种主流的缓存更新策略，另外还有Refrsh-Ahead模式等由于使用的不是很常见就不详细介绍了。

























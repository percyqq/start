https://hllvm-group.iteye.com/group/wiki/2858-JVM


Java中的参数传递时传值呢？还是传引用？
    要说明这个问题，先要明确两点：
         1. 不要试图与C进行类比，Java中没有指针的概念
         2. 程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。

   明确以上两点后。Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用（这点可以参考C的传值调用）。
    因此，很多书里面都说Java是进行传值调用，这点没有问题，而且也简化的C中复杂性。
    但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，
        也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。
        
   但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象。
    如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。
   
   对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），
    基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，
    如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。
  
   堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务，
    说白了堆就是一块共享的内存。不过，正是因为堆和栈的分离的思想，才使得Java的垃圾回收成为可能。
    
    
https://hllvm-group.iteye.com/group/wiki/2860-JVM    
在Java中，一个空Object对象的大小是8byte，这个大小只是保存堆中一个没有任何属性的对象的大小。看下面语句：
    Object ob = new Object();
    这样在程序中完成了一个Java对象的生命，但是它所占的空间为：4byte+8byte。4byte是上面部分所说的Java栈中保存引用的所需要的空间。
    而那8byte则是Java堆中对象的信息。
    因为所有的Java非基本类型的对象都需要默认继承Object对象，因此不论什么样的Java对象，其大小都必须是大于8byte。

   有了Object对象的大小，我们就可以计算其他对象的大小了。
Class NewObject {
    int count;
    boolean flag;
    Object ob;
}
其大小为：空对象大小(8byte)+int大小(4byte)+Boolean大小(1byte)+空Object引用的大小(4byte)=17byte。
    但是因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为24byte。
    这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把他们作为对象来看待。
    包装类型的大小至少是12byte（声明一个空Object至少需要的空间），而且12byte没有包含任何有效信息，
    同时，因为Java对象大小是8的整数倍，因此一个基本类型包装类的大小至少是16byte。这个内存占用是很恐怖的，
    它是使用基本类型的N倍（N>2），有些类型的内存占用更是夸张（随便想下就知道了）。
    
   因此，可能的话应尽量少使用包装类。在JDK5.0以后，因为加入了自动类型装换，因此，Java虚拟机会在存储方面进行相应的优化。
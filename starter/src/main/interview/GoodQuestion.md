拉链表
https://blog.csdn.net/saqin6255/article/details/80362248



count(1), * , 列 区别   count(列)不统计null？ 

解决难题，分布式事物，我们是底层交互服务，不应侵入过多的业务，我们只保证数据准确性，业务调用方来保证业务数据可靠性，一致性

CM架构。
抽象领域服务。公共服务、。≤µ。
消息对接收集。 
    商品 ->  多个物品，同一时间段扣减导致死锁。
自建gateway网关。

解决eureka发现502。
死锁： rc模式，分段扣减，大事务拆分，定时任务最终一致。
    死锁，商品–>物品，1对多，并发场景下订单扣减商品，会导致多个物品库存扣减，同一商户，同一物品，短时间内？
    另外是联合主键，以及主键趋势递增（锁住的范围存在了交集？）。

##kafka消息背压测试。


从javadoc的描述可以得出：
CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；
CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。

####
sla  Service-Level Agreement		它描述是双方的一种约定，是一种服务可用性的指标。服务可用性也是用百分比表示，但是与TP线含义不同
    tp99%表示 满足99%的请求所用的最大响应时间	可用性99%表示一定时间内提供服务的停机时间。
线上定位应用      IO先下手 io wait  db的io问题，日志/硬盘io问题，再到应用io， 最后才是服务。

tcc是属于 软状态，无法保证立刻的一致性，那么选择cp和ap在分布式事务的考虑是什么
【连接、读取、写入】
      超时问题解决
享元模式 ==> 线程池模型：  缓存模式
设计模式的分类，面向对象solid原则

数据库的连接池参数：testOnBorrow重点！   
	其中有一个属性 testOnBorrow 设置为false(默认设置为false) testOnBorrow=false由于不检测池里连接的可用性，
	于是假如连接池中的连接被数据库关闭了，应用通过连接池getConnection时，都可能获取到这些不可用的连接，且这些连接如果不被其他线程回收的话，它们不会被连接池被废除，也不会重新被创建，
	占用了连接池的名额，项目本身作为服务端，数据库链接被关闭，客户端调用服务端就会出现大量的timeout，客户端设置了超时时间，然而主动断开，服务端必然出现close_wait。
		1.maxActive连接池支持的最大连接数,
		2.maxIdle连接池中最多可空闲maxIdle个连接 ,这里取值为20,表示即使没有数据...
		3.minIdle连接池中最小空闲连接数,当连接数少于此值时,连接池会创建连接来补充到该值的...
		4.initialSize初始化连接数目
		5.maxWait连接池中连接用完时,新的请求等待时间,毫秒,这里取值-1,表示无限等待,直到超时为止,也可取值9000,表示9秒后...	

线程池隔离的考虑

服务发现和域名使用，ng层，对外是域名，内部是ip之类
微服务拆分
	领域、同一业务类型拆分，流量大小，稳定性，业务耗时
redis 热点数据库
mongo 大并发下写入性能差，不适合写多的场景

大批量insert报错处理。
######


https：
    1.内容加密：采用混合加密技术，中间者无法直接查看明文内容
    2.验证身份：通过证书认证客户端访问的是自己的服务器
    3.保护数据完整性：防止传输的内容被中间人冒充或者篡改

1.client向server发送请求: https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。
2.server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。
3.随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。
    区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。
    传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。
4.客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，
    提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。
5.客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。
6.传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。
7.服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。
8.客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。
9.同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。    
    中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，
    而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。
    
    
    

ArrayList的底层 transient 数组
zookeeper节点类型
bloomfilter
分库分表策略：

bio：
通常由一个独立的 Acceptor 线程负责监听客户端的连接。
    我们一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，
    就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 
    不过可以通过多线程来支持多个客户端的连接，。
NIO:同步非阻塞的I/O模型    
    IO流是阻塞的，NIO流是不阻塞的。
    IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。
    #NIO 通过Channel（通道） 进行读写。
    通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。
    4)Selectors(选择器)
    NIO有选择器，而IO没有。
    NIO 是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，
        频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。

1.首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色；
2.然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求；
3.为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常；
4.Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒；

方案一：对Key取模，除数逐步递增
方案二：按时间划分
方案三：按数值范围
方案四：一致性Hash理念——平均分布方案（大众点评用这种，200G并且一步到位）
方案五：一致性Hash理念——按迭代增加节点（为了方便增量迁移）
方案六：一致性Hash理念——按范围分库（迭代迁移）

    
AIO 也就是 NIO 2。
    异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。




TCP,UDP
jwt原理
    1. 头部（Header）
    2. 载荷（payload）
    3. 签名（signature）

Base64编码原理：它是基于64个可打印的字符来表示二进制的数据的一种方法。
    "A-Z、a-z、0-9、+、/" 64个可打印字符，这是标准的Base64协议规定。在日常使用中我们还会看到“=”或“==”号出现在Base64的编码结果中，
    “=”在此是作为填充字符出现，后面会讲到
    Base64字符表中的字符原本用6个bit就可以表示，现在前面添加2个0，变为8个bit，会造成一定的浪费。因此，Base64编码之后的文本，要比原文大约三分之一。
    为什么使用3个字节一组呢？因为6和8的最小公倍数为24，三个字节正好24个二进制位，每6个bit位一组，恰好能够分为4组。



对象头存储。

jvm cms详解
hashmap 2的n次方。


Zjava对象的几种创建方式：
1. 使用new关键字	                        → 调用了构造函数
2. 使用Class类的newInstance方法           → 调用了构造函数   无参的构造函数
      反射调用私有的构造方法： ===>  使用 SecurityManager 和足够严格的限制安全政策。
      
3. 使用Constructor类的newInstance方法     → 调用了构造函数   newInstance方法调用有参数的和私有的构造函数。
4. 使用clone方法	                        → 没有调用构造函数
5. 使用反序列化	                        → 没有调用构造函数  
        当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。
动态代理：
Proxy.newProxyInstance(Robot.class.getClassLoader(), new Class[] {Robot.class,Null.class},  


1. 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；
2. 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；
3. 反射也是考虑了线程安全的，放心使用；
4. 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；
5. 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；
6. 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；
7. 调度反射方法，最终是由jvm执行invoke0()执行；



反射方法调用：
Proxy target = new Proxy();
Method method = Proxy.class.getDeclaredMethod("run");
method.invoke(target);





gcroot哪些对象，如何确定
cms，mysql页数据大小，
线程池验证，core满，队列满，增大至max时，第一个来的请求和队列里的请求谁先执行。
无事物方法调用有事物。


GC Roots的对象包括下面几种：
>虚拟机栈（栈帧中的本地变量表）中的引用的对象；
>方法区中类静态属性引用的对象；
>方法区中常量引用的对象；
>本地方法栈中JNI（一般说的Native方法）的引用的对象。

2.2 CMS垃圾回收的6个重要阶段
1、initial-mark 初始标记（CMS的第一个STW阶段），标记GC Root直接引用的对象，GC Root直接引用的对象不多，所以很快。
2、concurrent-mark 并发标记阶段，由第一阶段标记过的对象出发，所有可达的对象都在本阶段标记。
3、concurrent-preclean 并发预清理阶段，也是一个并发执行的阶段。
    在本阶段，会查找前一阶段执行过程中,从[新生代]晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，
    预清理阶段可以减少下一个stop-the-world 重新标记阶段的工作量。

4、concurrent-abortable-preclean 并发可中止的预清理阶段。这个阶段其实跟上一个阶段做的东西一样，
    也是为了减少下一个STW重新标记阶段的工作量。
    增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认5秒）或者Eden区使用占比达到期望比例（默认50%）就结束本阶段。

5、remark 重标记阶段（CMS的第二个STW阶段），暂停所有用户线程，从GC Root开始重新扫描整堆，标记存活的对象。
    需要注意的是，虽然CMS只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，
    因为很多GC Root都在新生代，而这些GC Root指向的对象又在老年代，这称为“跨代引用”。

6、concurrent-sweep ，并发清理。



为什么选择网关： 【在高并发和潜在的高延迟场景下，网关要实现高性能高吞吐量的一个基本要求是全链路异步，不要阻塞线程。
    Zuul网关采用同步阻塞模式不符合要求。】
全局sso接入，cors配置，权限校验，
订单扣减拆分： 加菜，退菜，拆单，

1.自建gateway网关，底层基于netty，reactor非阻塞模式，优于cloud 1.0的zuul（thread-per-request处理模型，不支持任何长连接，如websockets）。
    即使在Controller方法上加@Async注解或返回DeferredResult、Callable类型的结果，
    其实仍只是把方法的同步调用封装成执行任务放到线程池的任务队列中，还是thread-per-request模型。
    Gateway 中Websockets得到支持，后续考虑做推送
  a.路由配置、
  b.断路器、
  c.限流、   基于令牌桶的限流过滤器、基于漏桶算法的限流过滤器    
            随着时间流逝，系统会按恒定 1/QPS 时间间隔（如果 QPS=100，则间隔是 10ms）往桶里加入 Token，如果桶已经满了就不再加了。
            每个请求来临时，会拿走一个 Token，如果没有 Token 可拿了，就阻塞或者拒绝服务。
            令牌桶的另外一个好处是可以方便的改变速度。一旦需要提高速率，则按需提高放入桶中的令牌的速率。一般会定时
            （比如 100 毫秒）往桶中增加一定数量的令牌，有些变种算法则实时的计算应该增加的令牌的数量。
  d.鉴权、
  e.cors、
  f.对外api接口统计


2.库存交易凭证，mongo 分片存储，3副本集提供服务，保证一致性不丢失，是系统交易信息的核心保证。
库存服务：
前置，分布式锁，保证库存扣减一致性，幂等。
中置，RC模式，减少间隙锁，分段扣减。
后置，定时任务，库存凭证扫描，计算报表数据差异，检查异常扣减。
    
3.抽象【核心业务领域层】：  供应链核心 ： 物品在【单据】之间的流转 和 库存。
a.基础公共服务，账户体系，提供分表路由。
b.物品服务，商品异步消息同步，大批量数据导入
d.单据服务，抽离，支持上层服务调用，后续可以接入流程引擎做单据履约。
c.出入库服务   对生产，报废，采购，销售，配送，盘点，订单各业务 提供基础的库存扣减，流水核对，为报表提供宽表计算数据


tcp 负载均衡为什么在4层，
Dbuuo 为什么实现自己的spi。 
一次rpc调用的过程。
序列化和反序列化

Netty的包。自定义协议。


https://www.cnblogs.com/jian0110/p/10650396.html

一、数据发布/订阅
 1）数据发布/订阅系统即所谓的配置中心，也就是发布者将数据发布到ZooKeeper的一个节点或者一系列节点上，提供订阅者进行数据订阅，
    从而实现动态更新数据的目的，实现配置信息的集中式管理和数据的动态更新。
    ZooKeeper采用的是推拉相结合的方式：客户端向服务器注册自己需要关注的节点，一旦该节点的数据发生改变，
    那么服务端就会向相应的客户端发送Wacher事件通知，客户端接收到消息通知后，需要主动到服务端获取最新的数据。
（2）实际系统开发过程中：我们可以将初始化配置信息放到节点上集中管理，应用在启动时都会主动到ZooKeeper服务端进行一次配置读取，
    同时在指定节点注册Watcher监听，主要配置信息一旦变更，订阅者就可以获取读取最新的配置信息。
    通常系统中需要使用一些通用的配置信息，比如机器列表信息、运行时的开关配置、数据库配置信息等全局配置信息，
    这些都会有以下3点特性：
　　1） 数据量通常比较小（通常是一些配置文件）
　　2） 数据内容在运行时会经常发生动态变化（比如数据库的临时切换等）
　　3） 集群中各机器共享，配置一致（比如数据库配置共享）。
（3）利用的ZooKeeper特性是：ZooKeeper对任何节点（包括子节点）的变更，
    只要注册Wacther事件（使用Curator等客户端工具已经被封装好）都可以被其它客户端监听

二、Master选举
 1）在一些读写分离的应用场景中，客户端写请求往往是由Master处理的，而另一些场景中，Master则常常负责处理一些复杂的逻辑，
    并将处理结果同步给集群中其它系统单元。
    比如一个广告投放系统后台与ZooKeeper交互，广告ID通常都是经过一系列海量数据处理中计算得到（非常消耗I/O和CPU资源的过程），
    那就可以只让集群中一台机器处理数据得到计算结果，之后就可以共享给整个集群中的其它所有客户端机器。
 2）利用ZooKeeper的特性：利用ZooKeeper的强一致性，即能够很好地保证分布式高并发情况下节点的创建一定能够保证全局唯一性，
    ZooKeeper将会保证客户端无法重复创建一个已经存在的数据节点，也就是说如果多个客户端请求创建同一个节点，
    那么最终一定只有一个客户端请求能够创建成功，这个客户端就是Master，而其它客户端注在该节点上注册子节点Wacther，
    用于监控当前Master是否存活，如果当前Master挂了，那么其余客户端立马重新进行Master选举。
 3）竞争成为Master角色之后，创建的子节点都是临时顺序节点，
    比如：_c_862cf0ce-6712-4aef-a91d-fc4c1044d104-lock-0000000001，并且[序号是递增的]。
    需要注意的是这里有"lock"单词，这说明ZooKeeper这一特性，也可以运用于分布式锁。

三、分布式锁
1、基本概念
　　（1）对于排他锁：ZooKeeper通过数据节点表示一个锁，例如/exclusive_lock/lock节点就可以定义一个锁，
    所有客户端都会调用create()接口，试图在/exclusive_lock下创建lock子节点，
    但是ZooKeeper的强一致性会保证所有客户端最终只有一个客户创建成功。
    也就可以认为获得了锁，其它线程Watcher监听子节点变化（等待释放锁，竞争获取资源）。

　　（2）对于共享锁：ZooKeeper同样可以通过数据节点表示一个锁，
        类似于/shared_lock/[Hostname]-请求类型（读/写）-序号的临时节点，比如/shared_lock/192.168.0.1-R-0000000000

2、代码示例
Curator提供的有四种锁，分别如下：
　　（1）InterProcessMutex：分布式可重入排它锁
　　（2）InterProcessSemaphoreMutex：分布式排它锁
　　（3）InterProcessReadWriteLock：分布式读写锁
　　（4）InterProcessMultiLock：将多个锁作为单个实体管理的容器

羊群效应：
    Zookeeper分布式锁场景中的羊群效应指的是所有的客户端都尝试对一个临时节点去加锁，当一个锁被占有的时候，
    其他的客户端都会监听这个临时节点。一旦锁被释放，Zookeeper反向通知添加监听的客户端，
    然后大量的客户端都尝试去对同一个临时节点创建锁，最后也只有一个客户端能获得锁，
    但是大量的请求造成了很大的网络开销，加重了网络的负载，影响Zookeeper的性能。
==== 
解决方案可以参考curator框架创建Zookeeper分布式锁的机制。
    1.所有客户端都尝试去创建临时有序节点以获取锁
    2.序号最小的临时有序节点获得锁
    3.未获取到锁的客户端给自己的上一个临时有序节点添加监听
    4.获得锁的客户端进行自己的操作，操作完成之后删除自己的临时有序节点
    5.当监听到自己的上一个临时有序节点释放了锁，尝试自己去加锁
    6.操作完成之后释放锁
    7.之后剩下的客户端重复加锁和解锁的操作

③zk 分布式锁
zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；
    这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。
    释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。
也可以采用另一种方式，创建临时顺序节点：
    如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；
    后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，
    一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。
    
6.Zookeeper实现分布式锁原理	http://www.imooc.com/article/284956?block_id=tuijian_wz			临时顺序节点
    使用zookeeper创建临时序列节点来实现分布式锁，适用于顺序执行的程序，大体思路就是
        创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，
        通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……
===>
    多个Jvm同时在Zookeeper上创建同一个相同的节点( /Lock)
    zk节点唯一的！ 不能重复！节点类型为临时节点， jvm1创建成功时候，jvm2和jvm3创建节点时候会报错，该节点已经存在。这时候 jvm2和jvm3进行等待。
    jvm1的程序现在执行完毕，执行释放锁。关闭当前会话。临时节点不复存在了并且事件通知Watcher，jvm2和jvm3继续创建。

大家都是上来直接创建一个锁节点下的一个接一个的临时顺序节点
如果自己不是第一个节点，就对自己上一个节点加监听器
只要上一个节点释放锁，自己就排到前面去了，相当于是一个排队机制。
    而且用临时顺序节点的另外一个用意就是，如果某个客户端创建临时顺序节点之后，不小心自己宕机了也没关系，zk感知到那个客户端宕机，
    会自动删除对应的临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队。    
    
    
    
https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961498&idx=1&sn=058097f882ff9d32f5cdf7922644d083&chksm=bd2d0d468a5a845026b7d2c211330a6bc7e9ebdaa92f8060265f60ca0b166f8957cbf3b0182c&scene=21#wechat_redirect



并发版本控制
==
总结
>(1)常见并发控制保证数据一致性的方法有锁，数据多版本；  
>(2)普通锁串行，读写锁读读并行，数据多版本读写并行；  
>(3)redo日志保证已提交事务的ACID特性，设计思路是，通过顺序写替代随机写，提高并发；  
>(4)undo日志用来回滚未提交的事务，它存储在回滚段里；  
>(5)InnoDB是基于MVCC的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；  
>(6)InnoDB之所以并发高，快照读不加锁；  
>(7)InnoDB所有普通select都是快照读；  


三，可重复读(Repeated Read, RR)
==
这是InnoDB默认的隔离级别，在RR下：  
*(1)普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，  
  底层使用MVCC来实现，共享锁与排他锁的玩法是：   
>共享锁之间不互斥，简记为：读读可以并行  
>排他锁与任何锁互斥，简记为：写读，写写不可以并行  
  
数据多版本是一种能够进一步提高并发的方法，它的核心原理是：    
>（1）写任务发生时，将数据克隆一份，以版本号区分；  
>（2）写任务操作新克隆的数据，直至提交；  
>（3）并发读任务可以继续读取旧版本的数据，不至于阻塞；  

*(2)加锁的select(select ... in share mode / select ... for update), update, delete等语句，它们的锁，  
>依赖于它们是否在唯一索引(unique index)上使用了唯一的查询条件(unique search condition)，  
>或者范围查询条件(range-type search condition)：  
>在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)，而不会封锁记录之间的间隔，
>即不会使用间隙锁(gap lock)与临键锁(next-key lock)范围查询条件，会使用间隙锁与临键锁，  
>锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复的读  


    InnoDB是高并发互联网场景最为推荐的存储引擎，根本原因，  
    就是其多版本并发控制（Multi Version Concurrency Control, MVCC）。  
    行锁，并发，事务回滚等多种特性都和MVCC相关。  
    MVCC就是通过“读取旧版本数据”来降低并发事务的锁冲突，提高任务的并发度。  


四、redo, undo,回滚段
==

为什么要有redo日志？    一句话，redo日志用于保障，已提交事务的ACID特性。
>数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。  
>磁盘随机写性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。  
>优化方式是，将修改行为先写到redo日志里（此时变成了顺序写），再定期将数据刷到磁盘上，这样能极大提高性能。  
  
为什么要有undo日志？    undo日志用于保障，未提交事务不会对数据库的ACID特性产生影响。
>数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，  
>当事务回滚时，或者数据库奔溃时，可以利用undo日志，  
>即旧版本数据，撤销未提交事务对数据库产生的影响。  

>对于insert操作，undo日志记录新数据的PK(ROW_ID)，回滚时直接删除；  
>对于delete/update操作，undo日志记录旧数据row，回滚时直接恢复；  
>他们分别存放在不同的buffer里。  

什么是回滚段？  
>存储undo日志的地方，是回滚段。  


索引总结
==
    数据库索引用于加速查询
    虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引
    InnoDB不支持哈希索引
    数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO
    局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO


数据库的索引最常用B+树：
(1)很适合磁盘存储，能够充分利用局部性原理，磁盘预读；
(2)很低的树高度，能够存储大量数据；
(3)索引本身占用的内存很小；
(4)能够很好的支持单点查询，范围查询，有序性查询；

(a)在索引结构中，非叶子节点存储key，叶子节点存储value；
(b)聚集索引，叶子节点存储行记录(row)；


InnoDB的主键索引与行记录是存储在一起的，故叫做聚集索引（Clustered Index）：
  1.没有单独区域存储行记录
  2.主键索引的叶子节点，存储主键，与对应行记录（而不是指针）
  ==> 聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。
  
InnoDB的每一个表都会有聚集索引：
(1)如果表定义了PK，则PK就是聚集索引；
(2)如果表没有定义PK，则第一个非空unique列是聚集索引；
(3)否则，InnoDB会创建一个隐藏的row-id作为聚集索引；



MyISAM的索引与行记录是分开存储的，叫做非聚集索引（UnClustered Index）。
其主键索引与普通索引没有本质差异：
  1.有连续聚集的区域单独存储行记录
  2.主键索引的叶子节点，存储主键，与对应行记录的指针
  3.普通索引的叶子结点，存储索引列，与对应行记录的指针
  
  
InnoDB的普通索引可以有多个，它与聚集索引是不同的：
普通索引的叶子节点，存储主键（也不是指针）

InnoDB的索引
  InnoDB的索引有两类索引，聚集索引(Clustered Index)与普通索引(Secondary Index)。
  
  
  

 对于InnoDB表，这里的启示是：
(1)不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；
(2)建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；

MyISAM和InnoDB都使用B+树来实现索引：
  MyISAM的索引与数据分开存储
  MyISAM的索引叶子存储指针，主键索引与普通索引无太大区别
  InnoDB的聚集索引和数据行统一存储
  InnoDB的聚集索引存储数据行本身，普通索引存储主键
  InnoDB一定有且只有一个聚集索引
  InnoDB建议使用趋势递增整数作为PK，而不宜使用较长的列作为PK

======================================================================================================================================

记录锁(Record Locks)     
  记录锁，它封锁索引记录，例如：
  select * from t where id=1 for update;
  
快照读(SnapShot Read)，它并不加锁，
  select * from t where id=1;
  
间隙锁(Gap Locks)
  间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。  
  
InnoDB，RR：
t(id PK, name KEY, sex, flag);
表中有四条记录：
  1, shenjian, m, A
  3, zhangsan, m, A
  5, lisi, m, A
  9, wangwu, f, B
  
这个SQL语句
select * from t     where id between 8 and 15     for update;
会封锁区间，以阻止其他事务id=10的记录插入。  
  
  间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。
  如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。 


临键锁(Next-Key Locks)
  临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。
  更具体的，临键锁会封锁索引记录本身，以及索引记录之前的区间。
  如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。
  
  临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。

PK上潜在的临键锁为：

(-infinity, 1]
(1, 3]
(3, 5]
(5, 9]
(9, +infinity]


总结

(1)InnoDB的索引与行记录存储在一起，这一点和MyISAM不一样；
(2)InnoDB的聚集索引存储行记录，普通索引存储PK，所以普通索引要查询两次；
(3)记录锁锁定索引记录；
(4)间隙锁锁定间隔，防止间隔中被其他事务插入；
(5)临键锁锁定索引记录+间隔，防止幻读；



======================================================================================================================================
https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961461&idx=1&sn=b73293c71d8718256e162be6240797ef&chksm=bd2d0da98a5a84bfe23f0327694dbda2f96677aa91fcfc1c8a5b96c8a6701bccf2995725899a&scene=21#wechat_redirect
InnoDB并发插入，居然使用意向锁？

一，共享/排它锁(Shared and Exclusive Locks)

《InnoDB并发为何这么高？》一文介绍了通用的共享/排它锁，在InnoDB里当然也实现了标准的行级锁(row-level locking)，共享/排它锁：
  (1)事务拿到某一行记录的共享S锁，才可以读取这一行；
  (2)事务拿到某一行记录的排它X锁，才可以修改或者删除这一行；
其兼容互斥表如下：
        S         X
S      兼容      互斥
X      互斥      互斥

即：
(1)多个事务可以拿到一把S锁，读读可以并行；
(2)而只有一个事务可以拿到X锁，写写/读写必须互斥；
共享/排它锁的潜在问题是，不能充分的并行，解决思路是数据多版本


二，意向锁(Intention Locks)
  InnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存，实际应用中，InnoDB使用的是意向锁。
  意向锁是指，未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向。

意向锁有这样一些特点：
(1)首先，意向锁，是一个表级别的锁(table-level locking)；
(2)意向锁分为：
  意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁
  意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁

举个例子：
select ... lock in share mode，要设置IS锁；
select ... for update，要设置IX锁；

(3)意向锁协议(intention locking protocol)并不复杂：
  事务要获得某些行的S锁，必须先获得表的IS锁
  事务要获得某些行的X锁，必须先获得表的IX锁

(4)由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行，其兼容互斥表如下：
         IS        IX
IS      兼容      兼容
IX      兼容      兼容

 
(5)额，既然意向锁之间都相互兼容，那其意义在哪里呢？它会与共享锁/排它锁互斥，其兼容互斥表如下：
         S         X
IS      兼容      互斥
IX      互斥      互斥
画外音：排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。


三，插入意向锁(Insert Intention Locks)

对已有数据行的修改与删除，必须加强互斥锁X锁，那对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。
插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。
画外音：有点尴尬，间隙锁下一篇文章才会介绍，暂且理解为，它是一种实施在索引上，锁定索引某个区间范围的锁。

它的玩法是：
多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。
画外音：官网的说法是

Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.


在MySQL，InnoDB，RR下：
t(id unique PK, name);

数据表中有数据：
10, shenjian
20, zhangsan
30, lisi

事务A先执行，在10与20两条记录中插入了一行，还未提交：
insert into t values(11, xxx);

事务B后执行，也在10与20两条记录中插入了一行：
insert into t values(12, ooo);

(1)会使用什么锁？
(2)事务B会不会被阻塞呢？
回答：虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：
  使用的是插入意向锁
  并不会阻塞事务B


思路总结

(1)InnoDB使用共享锁，可以提高读读并发；
(2)为了保证数据强一致，InnoDB使用强互斥锁，保证同一行记录修改与删除的串行性；
(3)InnoDB使用插入意向锁，可以提高插入并发；




缓冲池(buffer pool)
https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962450&idx=1&sn=ce17c4da8d20ce275f75d0f2ef5e40c9&chksm=bd2d098e8a5a809834aaa07da0d7546555385543fb6d687a7cf94d183ab061cd301a76547411&scene=21#wechat_redirect


